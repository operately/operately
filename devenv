#!/usr/bin/env bash

#
# A wrapper around the docker command to make it easier to run commands in 
# the app container accross Linux and MacOS. On MacOS, the user and group
# ids are different than on Linux, so we need to pass them in as environment
# variables to the container. This script will set the USER_ID and GROUP_ID
# environment variables to the current user and group ids.
#
# The USER_ID and GROUP_ID environment variables are used in the docker-compose.yml
# file to set the user and group ids in the app container that is the same as the
# current user and group ids on the host machine. This is done to avoid permission
# issues when creating files in the app container.
#

#
# Usage:
#
#   devenv build       - Build the app container
#   devenv up          - Start the app container
#   devenv stop        - Stop the app container
#   devenv down        - Stop and remove the app container
#   devenv teardown    - Fully reset the local development environment
#   devenv shell       - Start a shell in the app container
#   devenv <command>   - Run a command in the running app container
#

case "$(uname -s)" in
  Linux)
    #
    # On Linux, we want to pass in the user and group ids as environment variables
    # to the container so that the user and group ids in the container are the same
    # as the user and group ids on the host machine. This is done to avoid permission
    # issues when creating files in the app container.
    #

    export GROUP_ID=$(id -g) 
    export USER_ID=$(id -u) 
    ;;
  Darwin)
    #
    # On MacOS, the user and group ids are different than on Linux and can't be
    # passed in as environment variables. Instead, we'll set the USER_ID and GROUP_ID
    # environment variables to 1000, which is the default user and group id in the
    # app container.
    #
    # This will on MacOS because Docker Desktop for Mac uses a file sharing system
    # that doesn't require the user and group ids to be the same in the container
    # as on the host machine.
    
    export GROUP_ID=1000
    export USER_ID=1000
    ;;
  *)
    echo "Unsupported OS"
    exit 1
    ;;
esac

FIRST_ARG=$1

#
# Profile:
# 
# Determine if we are running in CI or locally and set the docker compose profile
# accordingly. In CI, we want to run the "ci" profile which does not include services
# like pgweb and mailhog. Locally, we want to run the "dev"
#

if [ "$CI" = "true" ]; then
  PROFILE="ci"
else
  PROFILE="dev"
fi

#
# PORT OFFSET:
#
# We want to be able to run multiple instances of the app on the same machine
# without port conflicts. To do this, we will use a PORT_OFFSET environment variable
# that will be added to the base port numbers for each service. The PORT_OFFSET
# can be set in a .env file in the root of the project. If the PORT_OFFSET is not
# set, it will default to 4000.
#
if [ -f .env ]; then
  PORT_OFFSET=$(grep '^PORT_OFFSET=' .env | cut -d '=' -f2)
  if [ -z "$PORT_OFFSET" ]; then
    PORT_OFFSET=4000
  fi
else
  PORT_OFFSET=4000
fi

export PORT_DEV_SERVER=$((PORT_OFFSET + 0))
export PORT_TEST_SERVER=$((PORT_OFFSET + 2))
export PORT_STORYBOOK_SERVER=$((PORT_OFFSET + 3))
export PORT_SCREENSHOTS=$((PORT_OFFSET + 4))
export PORT_VITE_SERVER=$((PORT_OFFSET + 5))
export PORT_PGWEB=$((PORT_OFFSET + 6))
export PORT_S3MOCK=$((PORT_OFFSET + 7))
export PORT_MAILHOG_UI=$((PORT_OFFSET + 8))
export PORT_ACME_DEV=$((PORT_OFFSET + 9))
export PORT_ACME_TEST=$((PORT_OFFSET + 10))

#
# Main entry point
#
# - devenv shell - start a shell in the app container
# - devenv up    - start the app container
# - devenv stop  - stop the app container
# - devenv down  - stop and remove the app container
# - devenv restart - restart the app container
# - devenv teardown - remove containers, volumes, and generated data
# - devenv <command> - run a command in the running app container
#
if [ "$FIRST_ARG" = "shell" ]; then
  docker compose exec app bash
elif [ "$FIRST_ARG" = "up" ]; then
  docker compose --profile ${PROFILE} up -d
  docker compose exec -u root app sh -c "addgroup -g $GROUP_ID usergroup 2>/dev/null || true"
  docker compose exec -u root app sh -c "adduser -D -u $USER_ID -G usergroup -s /bin/bash dev 2>/dev/null || true"
  docker compose exec -u dev app sh -c "echo \"export PS1='\w $ '\" >> /home/dev/.bashrc"
  docker compose exec -u dev app sh -c "echo \"export PS1='\w $ '\" >> /home/dev/.bash_profile"
elif [ "$FIRST_ARG" = "stop" ]; then
  docker compose --profile ${PROFILE} stop
elif [ "$FIRST_ARG" = "down" ]; then
  docker compose --profile ${PROFILE} down
elif [ "$FIRST_ARG" = "restart" ]; then
  docker compose --profile ${PROFILE} down && docker compose --profile ${PROFILE} up -d --force-recreate
elif [ "$FIRST_ARG" = "teardown" ]; then
  echo "Stopping containers and removing volumes..."
  docker compose --profile ${PROFILE} down --volumes --remove-orphans

  echo "Removing generated directories..."
  CLEANUP_PATHS=("locals3root" "media" "screenshots" "tmp")

  for path in "${CLEANUP_PATHS[@]}"; do
    if [ -e "$path" ]; then
      rm -rf "$path"
    fi
  done

  mkdir -p locals3root media screenshots tmp/certs

  echo "Local development environment reset complete."
else
  docker compose exec app "$@"
fi
